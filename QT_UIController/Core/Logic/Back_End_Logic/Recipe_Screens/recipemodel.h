/**************************************************************************

      Copyright (c) Branson Ultrasonics Corporation, 1996-2023

     This program is the property of Branson Ultrasonics Corporation
     Copying of this software is expressly forbidden, without the prior
     written consent of Branson Ultrasonics Corporation.

---------------------------- MODULE DESCRIPTION ----------------------------
    This file updates the recipe card screen.
--------------------------- REVISION HISTORY ------------------------------
 rev1: 21/07/2023 - Initial version.
***************************************************************************/

#ifndef RECIPEMODEL_H
#define RECIPEMODEL_H

#include <QObject>
#include <QAbstractListModel>
#include "recipegeneral.h"
#include "UpdateScreens.h"
#include "WeldRecipeAce.h"


class RecipeModel : public QAbstractListModel
{
    Q_OBJECT
public:
    enum RecipesRoles {
        IndexRole = Qt::UserRole + 1,
        NumberRole,
        NameRole,
        CompanyNameRole,
        WeldModeRole,
        WeldModeUnitRole,
        WeldModeValueRole,
        ActiveStatusRole,
        ValidateStatusRole,
        ModifiedStatusRole,
        NewCardStatusRole,
        CycleCountRole,
        VersionInfoRole,
        IsSavedRole
    };
public:
    explicit RecipeModel(QObject *parent = nullptr);
    ~RecipeModel();

    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
    QModelIndex index(int row, int column, const QModelIndex &index = QModelIndex()) const override;

    //Branson definition interface for the QML actions
    Q_INVOKABLE bool insertRow(int row);
    Q_INVOKABLE bool removeRow(int row, int index);
    Q_INVOKABLE bool resetCycleCount(int row, int index);
    Q_INVOKABLE bool setAsActive(int row, int index, bool isValidated);
    Q_INVOKABLE void loadRecipeCards();
    Q_INVOKABLE bool createNewRecipeFromWeldMode();
    Q_INVOKABLE void initiateRecipeCopyRequest(int SourceRecipeNo, int DestinationRecipeNo, bool IsReConfirmed);
    Q_INVOKABLE int  getActiveRecipeNumber();



private:
    std::map<int, RecipeCardDataACEStruct> m_MyRecipeCardDataMap;
    void createNewRecipe();
    void clearRecipes();
    void addNewRecipe(RecipeGeneral *recipe);
    bool initProductionValue();
    pthread_mutex_t mtx;
    WeldRecipeACE *m_MyRecipeCardsData;
    bool m_IsActiveRecipeSaved;

    int m_ActiveWelderId = -1;

protected:
    QHash<int, QByteArray> roleNames() const override;
private:
    QList<RecipeGeneral*> m_listRecipe;
    const QString strNewRecipeName = "New Recipe";
    const int intNewRecipeValue = 0;
    const QString strNewRecipeUnit  = "s";

signals:

    /*Signal to notify recipe cards limit*/
    void maxRecipeCountReached();
    void recipeDeleteError();
    void recipeOverride(int DestinationRecipeNo);

    /*Slot to be called when data update signal generated by communication thread*/
private slots:
    void OnRecipeCardsUpdated(WeldRecipeACE *RecipeCardsData_Obj, int WelderId);
};

#endif // RECIPEMODEL_H
